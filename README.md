# Распределенное Key-Value хранилище на базе B+Tree

conda env create -f environment-py312.yml

- Ключи (значения!) храниятся в простом питоновском списке
- данные (строки) также хранятсяв простом питоновском скиске списке либо на другом сервере
  - в случае, если в списке, то вариант:
    - данные - это объект некоторого класса, у которого имеется метод get_pkey()
      который возвращает структуру вида: 
      ````python
        class <ИмяКлассаКлюча>(msgpack.Struct, freeze=True, order=True):
            """ это первичный ключ 
                freeze=True - неизменяемое
                order=True содержит методы сравнения >, <, ==, >=, <=
            """
            <список полей>
      ````
- Само B+Tree дерево содержит только ссылки на ключи в виде numpy.int32

- Существует два вида узлов - `листовые` и `внутренние`
  - они отличаются друг от друга наличием поля `descendants` во внутренних узлах
- В качестве ключей используется msgspec.Struct
- Реализация уникальных/неуникальных индексов:
  - на самом деле, все индексы - уникальны, т.к. уникальным образом
    идентифицируют запись
  - поэтому для неуникальных индексов нужно лишь включить в значение ключа указатель на конкретную запись
    и индекс сразу станет уникальным

- при вставке в заполненный узел сначала выполняется операция расщепления (рекурсивно)
  - после процедуры расщепления определяется в какую из двух незаполненных таблиц нужно вставить запись
  - поэтому процедуре расщепления необходимо знать лишь ключ по которому расщепление было выполнено + код узла, на которорый переходить

DONE:
- INSERT: key
- validate BPTree
- min
- find: == key
- max

TODO:
- copy()
- async copy() - создает копию индекса без удаленных записей

- change_log_id - идентификатор изменения лога

- UPSERT: key
- UPDATE: key
- UPSERT: key

- scan: >, >= key
- scan: <, <= key

- DELETE: key

TODO:
- Raft consensus algorithm - для кластерной версии
- удаленные записи (их идентификаторы) должны сохраниться и переиспользоваться новыми записями

# PERSISTANCE / DURАBILITY

- Пока дерево относительно маленькое ~ 10M, вполне допустимо восстанавливать его из транзакционного лога.
- Когда лог раздулся достаточно сильно, создаем дополнительный индекс - но пустой.
- Все добавления/удаления пойдут в этот, вновь созданный индекс.
- старый будет доступен на чтение, и если приходит какая-либо операция, то сначала выполняется поиск в новом дереве
  а затем в старом. В старом данные не меняются! 
  - тем временем старый индекс сохраняется на диске в отсортированном виде, 
    что позволяет выполнять поиск без создания индекса.
  - таким образом в памяти будет всегда 3 структуры
    - горячий индекс (куда заносятся все изменения)
    - старый индекс для чтения
    - сортированный массив старых ключей.
    - как только старый индекс сброшен на диск в отсортированный файл, он удаляется из памяти,
      а сортированный список поднимается в память.


# Удаление (Если только помечать записи на удаление)
- как известно, удаление также можно реализовать в B+Tree, однако, какие выгоды мы получим от этого?
  - поиск того, что ключ удален все равно нужно проводить
  - при удалении тогда не нужно проводить модификацию дерева, а следовательно, все будет работать быстрее.
  - но если ключ встретится во внутреннем узле, т.е. раньше чем мы дойдем до листового уровня,
    то и то, что ключ удален - мы узнаем раньше.
  - при вставке уже удаленного ключа нам не нужно будет выполнять модификацию дерева
  - всегда можно будет выполнить компактизацию - создание/копирование дерева из уже имеющихся неудаленных ключей
